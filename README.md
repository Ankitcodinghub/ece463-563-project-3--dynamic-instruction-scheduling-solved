# ece463-563-project-3--dynamic-instruction-scheduling-solved
**TO GET THIS SOLUTION VISIT:** [ECE463/563  Project #3- Dynamic Instruction Scheduling Solved](https://www.ankitcodinghub.com/product/ece463-563-project-3-dynamic-instruction-scheduling-version-1-0-solved/)


---

üì© **If you need this solution or have special requests:** **Email:** ankitcoding@gmail.com  
üì± **WhatsApp:** +1 419 877 7882  
üìÑ **Get a quote instantly using this form:** [Ask Homework Questions](https://www.ankitcodinghub.com/services/ask-homework-questions/)

*We deliver fast, professional, and affordable academic help.*

---

<h2>Description</h2>



<div class="kk-star-ratings kksr-auto kksr-align-center kksr-valign-top" data-payload="{&quot;align&quot;:&quot;center&quot;,&quot;id&quot;:&quot;126645&quot;,&quot;slug&quot;:&quot;default&quot;,&quot;valign&quot;:&quot;top&quot;,&quot;ignore&quot;:&quot;&quot;,&quot;reference&quot;:&quot;auto&quot;,&quot;class&quot;:&quot;&quot;,&quot;count&quot;:&quot;4&quot;,&quot;legendonly&quot;:&quot;&quot;,&quot;readonly&quot;:&quot;&quot;,&quot;score&quot;:&quot;5&quot;,&quot;starsonly&quot;:&quot;&quot;,&quot;best&quot;:&quot;5&quot;,&quot;gap&quot;:&quot;4&quot;,&quot;greet&quot;:&quot;Rate this product&quot;,&quot;legend&quot;:&quot;5\/5 - (4 votes)&quot;,&quot;size&quot;:&quot;24&quot;,&quot;title&quot;:&quot;ECE463\/563&nbsp;  Project #3- Dynamic Instruction Scheduling  Solved&quot;,&quot;width&quot;:&quot;138&quot;,&quot;_legend&quot;:&quot;{score}\/{best} - ({count} {votes})&quot;,&quot;font_factor&quot;:&quot;1.25&quot;}">

<div class="kksr-stars">

<div class="kksr-stars-inactive">
            <div class="kksr-star" data-star="1" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="2" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="3" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="4" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="5" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>

<div class="kksr-stars-active" style="width: 138px;">
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>
</div>


<div class="kksr-legend" style="font-size: 19.2px;">
            5/5 - (4 votes)    </div>
    </div>
<span style="font-size: 2.61792em;letter-spacing: -1px">1.&nbsp; Preliminary Information</span>

<ul>
<li><strong>Source code:</strong> Each student must design and write their source code alone. They must do this (design and write their source code) without the assistance of any other person in ECE 463/563 or not in ECE 463/563.&nbsp; They must do this (design and write their source code) without searching the web for past semesters‚Äô projects and without searching the web for source code with similar goals (<em>g.</em>, modeling computer architecture components such as caches, predictors, pipelines, <em>etc</em>.), which is strictly forbidden.&nbsp; They must do this (design and write their source code) without looking at anyone else‚Äôs source code, without obtaining electronic or printed copies of anyone else‚Äôs source code, <em>etc</em>.&nbsp; Use of ChatGPT or other generative AI tools is prohibited.</li>
<li><strong>Explicit debugging:</strong> With respect to ‚Äúexplicit debugging‚Äù as part of the coding process (<em>g.</em>, using a debugger, inspecting code for bugs, inserting prints in the code, iteratively applying fixes, <em>etc</em>.), each student must explicitly debug their code without the assistance of any other person in ECE 463/563 or not in ECE 463/563.</li>
<li><strong>Report:</strong> Each student must run their own experiments, collect and process their own data, and write their own report. Plagiarism (lifting text, graphs, illustrations, <em>etc</em>., from someone else, whether one adjusts the originals or not) is prohibited.&nbsp; Using someone else‚Äôs data (in raw form and/or graph form) is prohibited.&nbsp; Fabricating data is prohibited. o <strong>Sanctions:</strong> The sanctions for violating the academic integrity policy are (1) a score of 0 on the project and (2) academic integrity probation for a first-time offense or suspension for a subsequent offense (the latter sanctions are administered by the Office of Student Conduct).&nbsp; Note that, when it comes to academic integrity violations, both the giver and receiver of aid are responsible and both are sanctioned.&nbsp; Please see the following RAIV form which has links to various policies and procedures and gives a sense of how academic integrity violations are confronted, documented, and sanctioned: <a href="https://go.ncsu.edu/RAIV">RAIV form</a><a href="https://go.ncsu.edu/RAIV">.</a>&nbsp; o <strong>Enforcement:</strong> The TAs will scan source code (from current and past semesters) through tools available to us for detecting cheating. The outputs from these tools, combined with in-depth manual analysis of these outputs, will be the basis for investigating suspected academic integrity violations.&nbsp; TAs will identify suspected plagiarism and/or data fabrication and these cases will be investigated.</li>
<li>Reasonable assistance: If a student has any doubts or questions, or if a student is stumped by a bug, the student is encouraged to seek assistance using both of the following channels. o Students may receive assistance from the TAs and instructor.
<ul>
<li>Students are encouraged to post their doubts, questions, and obstacles, on the Moodle message board for this project. The instructor and TAs will moderate the message board to ensure that reasonable assistance is provided to the student.&nbsp; To strictly abide by the ‚Äúno collaboration policy‚Äù, students may not reply to other students‚Äô project queries unless the instructor solicits input from other students for a particular query.
<ul>
<li>An example of reasonable assistance via the message board: Student A: ‚Äú<em>I‚Äôm encountering the following problem: I‚Äôm getting fewer writebacks from L2 to main memory than the validation runs. What might I be doing wrong?</em>‚Äù Instructor/TA: ‚Äú<em>Maybe you have implemented evictions in more than one place in your code rather than consolidating it into one place (efficient and less bug-prone).&nbsp; If so, make sure you are checking for and counting evicted dirty blocks at all such locations (or try to implement evictions at one place in the code).</em>‚Äù</li>
<li>Another example of a reasonable exchange: Student A: ‚Äú<em>I‚Äôm unsure how to split the address into tag and index, and how to discard the block offset bits. I‚Äôve successfully computed the # bits for each but I am stuck on how to manipulate the address in C/C++. Do you have any advice?</em>‚Äù Instructor/TA: ‚Äú<em>We suggest you use an unsigned integer type for the address and use bitwise manipulation, such as ANDs (&amp;), ORs (|), and left/right shifts (&lt;&lt;. &gt;&gt;) to extract values from the unsigned integer, the same as one would do in Verilog.</em>‚Äù</li>
<li>Another example of a reasonable exchange: Student A: ‚Äú<em>I‚Äôm unsure how to dynamically allocate memory, such as dynamically allocating a 1D array of structs/classes or (more appropriately for a cache) a 2D array of structs/classes. Can you point me to some references on this?</em>‚Äù Instructor/TA: ‚Äú<em>Sure, here is a web site or reference book that discusses dynamic memory allocation including 1D and 2D arrays.</em>‚Äù</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>1.2.&nbsp;&nbsp;&nbsp; Same project scope for both ECE 463 and ECE 563 students</h2>
Unlike previous projects, the scope of this project is the same for both ECE 463 and ECE 563 students. This is because the OOO pipeline must be modeled in its entirety to measure cycles to execute a trace. Note that the project focuses on modeling data dependencies (only through registers), pipeline stages, and structural hazards (Issue Queue and Reorder Buffer). Therefore, we assume perfect branch prediction and perfect caches, and ignore memory dependencies: you will NOT integrate a BTB, conditional branch predictor, instruction cache/TLB, data cache/TLB, or Load Queue/Store Queue.

<h2>1.3.&nbsp;&nbsp;&nbsp; Programming languages for this project</h2>
You must implement your project using the C, C++, or Java languages, for two reasons. First, these languages are preferred for computer architecture performance modeling. Second, our Gradescope autograder only supports compilation of these languages.

<strong><em>1.4.&nbsp; Responsibility for self-grading your project via Gradescope </em></strong><u>You will submit, validate, and SELF-GRADE your project via Gradescope; the TAs will only</u> <u>manually grade the report. While you are developing your simulator, you are required to</u> <u>frequently check via Gradescope that your code compiles, runs, and gives expected outputs with</u> <u>respect to your current progress. This is necessary to resolve porting issues in a timely fashion</u> <u>(<em>i.e.</em>, well before the deadline), caused by different compiler versions in your programming</u> <u>environment and the Gradescope backend. This is also necessary to resolve non-compliance</u> <u>issues (<em>i.e.</em>, how you specify the simulator‚Äôs command-line arguments, how you format the</u> <u>simulator‚Äôs outputs, <em>etc</em>.) in a timely fashion (<em>i.e.</em>, well before the deadline).</u>

<h1>2.&nbsp; Project Description</h1>
In this project, you will construct a simulator for an out-of-order superscalar processor that fetches and issues <em>N</em> instructions per cycle. Only the dynamic scheduling mechanism will be modeled in detail, <em>i.e.</em>, perfect caches and perfect branch prediction are assumed.

<h1>3.&nbsp; Inputs to Simulator</h1>
<h2>3.1.&nbsp; Traces</h2>
The simulator reads a trace file in the following format:

&nbsp;

&lt;PC&gt; &lt;operation type&gt; &lt;dest reg #&gt; &lt;src1 reg #&gt; &lt;src2 reg #&gt;

&lt;PC&gt; &lt;operation type&gt; &lt;dest reg #&gt; &lt;src1 reg #&gt; &lt;src2 reg #&gt;&nbsp; ‚Ä¶

&nbsp;

Where:

<ul>
<li>&lt;PC&gt; is the program counter of the instruction (in hex). o &lt;operation type&gt; is either ‚Äú0‚Äù, ‚Äú1‚Äù, or ‚Äú2‚Äù.</li>
<li>&lt;dest reg #&gt; is the destination register of the instruction. If it is <strong>-1</strong>, then the instruction does not have a destination register (for example, a conditional branch instruction). Otherwise, it is between 0 and 66.</li>
<li>&lt;src1 reg #&gt; is the first source register of the instruction. If it is <strong>-1</strong>, then the instruction does not have a first source register. Otherwise, it is between 0 and 66.</li>
<li>&lt;src2 reg #&gt; is the second source register of the instruction. If it is <strong>-1</strong>, then the instruction does not have a second source register. Otherwise, it is between 0 and 66.</li>
</ul>
&nbsp;

For example:

&nbsp;

ab120024&nbsp; 0&nbsp;&nbsp; 1&nbsp; 2&nbsp; 3 ab120028&nbsp; 1&nbsp;&nbsp; 4&nbsp; 1&nbsp; 3 ab12002c&nbsp; 2&nbsp; -1&nbsp; 4&nbsp; 7

&nbsp;

Means:

&nbsp;

‚Äúoperation type 0‚Äù&nbsp; R1, R2, R3

‚Äúoperation type 1‚Äù&nbsp; R4, R1, R3

‚Äúoperation type 2‚Äù&nbsp; -, R4, R7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <em>no destination register!</em>

&nbsp;

Traces are posted on the Moodle website.

&nbsp;

<h2>3.2.&nbsp; Command-line arguments to the simulator</h2>
The simulator executable built by your Makefile must be named ‚Äúsim‚Äù (the Makefile is discussed in Section 6).

&nbsp;

Your simulator must accept command-line arguments as follows:

&nbsp;

sim &lt;ROB_SIZE&gt; &lt;IQ_SIZE&gt; &lt;WIDTH&gt; &lt;tracefile&gt;

&nbsp;

The parameters &lt;ROB_SIZE&gt;, &lt;IQ_SIZE&gt;, and &lt;WIDTH&gt;, are explained in Section 5.

&lt;tracefile&gt; is the filename of the input trace.

<h1>4.&nbsp; Outputs from Simulator</h1>
The simulator first outputs the timing information for each dynamic instruction in program order, followed by final outputs (simulator command, processor configuration, and simulation results).

&nbsp;

<u>See Section 6 regarding the formatting of these outputs and validating your simulator.</u>

&nbsp;

<h2>4.1.&nbsp; Timing information for each dynamic instruction</h2>
The simulator outputs the timing information for each dynamic instruction in the trace, in program order (<em>i.e.</em>, in the same order that instructions appear in the trace). The per-instruction timing information is output in the following format:

&nbsp;

&lt;seq_no&gt; <strong>fu{</strong>&lt;op_type&gt;<strong>}</strong> <strong>src{</strong>&lt;src1&gt;,&lt;src2&gt;<strong>}</strong> <strong>dst{</strong>&lt;dst&gt;<strong>}</strong>

<strong>FE{</strong>&lt;begin-cycle&gt;,&lt;duration&gt;<strong>}</strong> <strong>DE{</strong>‚Ä¶<strong>} RN{</strong>‚Ä¶<strong>} RR{</strong>‚Ä¶<strong>}</strong> <strong>DI{</strong>‚Ä¶<strong>} IS{</strong>‚Ä¶<strong>}</strong> <strong>EX{</strong>‚Ä¶<strong>}</strong> <strong>WB{</strong>‚Ä¶<strong>} RT{</strong>‚Ä¶<strong>} </strong>

&nbsp;

&lt;seq_no&gt; is the line number in trace (<em>i.e.</em>, the dynamic instruction count), starting at 0. Substitute 0, 1, or 2 for the &lt;op_type&gt;. &lt;src1&gt;, &lt;src2&gt;, and &lt;dst&gt; are register numbers

(include ‚Äì1 if that is the case). For each of the pipeline stages, indicate the first cycle that the instruction was in that pipeline stage followed by the number of cycles the instruction was in that pipeline stage.

&nbsp;

Here is an example instruction from one of the validation runs.

&nbsp;

5 fu{2} src{15,-1} dst{16} FE{5,1} DE{6,1} RN{7,1} RR{8,1} DI{9,1} IS{10,3} EX{13,5} WB{18,1} RT{19,1}

&nbsp;

Notice that the begin-cycle of a given pipeline stage equals the begin-cycle of the immediately preceding pipeline stage plus the number of cycles spent in the immediately preceding pipeline stage. For example, the instruction‚Äôs first cycle in the <strong>EX</strong> stage is cycle 13, which is the first cycle in <strong>IS</strong> (10) plus the number of cycles spent in <strong>IS</strong> (3).

<h2>4.2.&nbsp; Final outputs</h2>
The simulator outputs the following after completion of the run:

<ol>
<li>Simulator command.</li>
<li>Processor configuration.</li>
<li>Simulation results:
<ol>
<li>Dynamic instruction count. (Total number of retired instructions.)</li>
<li>(Total number of cycles to retire all instructions.)</li>
<li>Instructions per cycle (IPC). (item a divided by item b, above)</li>
</ol>
</li>
</ol>
&nbsp;

<h1>5.&nbsp; Simulator Specification</h1>
<h2>5.1.&nbsp; Microarchitecture to be Modeled</h2>
&nbsp;

&nbsp;

<strong>Figure 1.&nbsp; Overview of microarchitecture to be modeled, including the terminology and parameters used throughout this specification. </strong>

&nbsp;

<strong>Parameters: </strong>

<ol>
<li>Number of architectural registers: The number of architectural registers specified in the ISA is 67 (r0-r66).<a href="#_ftn1" name="_ftnref1"><sup>[1]</sup></a> The number of architectural registers determines the number of entries in the Rename Map Table (RMT) and Architectural Register File (ARF).</li>
<li>WIDTH: This is the superscalar width of all pipeline stages, in terms of the maximum number of instructions in each pipeline stage. The one exception is Writeback: the number of instructions that may complete execution in a given cycle is not limited to WIDTH (this is explained below).</li>
<li>IQ_SIZE: This is the number of entries in the Issue Queue (IQ).</li>
<li>ROB_SIZE: This is the number of entries in the Reorder Buffer (ROB).</li>
</ol>
&nbsp;

<strong>Function units: </strong>

There are WIDTH universal pipelined function units (FUs). Each FU can execute any type of instruction (hence the term ‚Äúuniversal‚Äù). The operation type of an instruction indicates its execution latency: Type 0 has a latency of 1 cycle, Type 1 has a latency of 2 cycles, and Type 2

&nbsp;

has a latency of 5 cycles. Each FU is fully pipelined. Therefore, a new instruction can begin execution on a FU every cycle.

&nbsp;

<strong>Pipeline registers: </strong>

The pipeline stages shown in Figure 1 are separated by pipeline registers. In general, this spec names a pipeline register based on the stage that it feeds into. For example, the pipeline register between Fetch and Decode is called DE because it feeds into Decode. A ‚Äúbundle‚Äù is the set of instructions in a pipeline register. For example, if DE is not empty, it contains a ‚Äúdecode bundle‚Äù.

Table 1 lists the names of the pipeline registers used in this spec. It also provides a description of each pipeline register and its size (max # instructions).

<strong>Table 1.&nbsp; Names, descriptions, and sizes of all of the&nbsp; pipeline registers. </strong>

<table width="638">
<tbody>
<tr>
<td width="127"><strong>Pipeline Register </strong></td>
<td width="198"><strong>Description </strong></td>
<td width="313"><strong>Size (max # instructions) </strong></td>
</tr>
<tr>
<td width="127">DE</td>
<td width="198">pipeline register between

the Fetch and Decode stages

&nbsp;
</td>
<td width="313">WIDTH</td>
</tr>
<tr>
<td width="127">RN</td>
<td width="198">pipeline register between the Decode and Rename

stages
</td>
<td width="313">WIDTH</td>
</tr>
<tr>
<td width="127">RR</td>
<td width="198">pipeline register between the Rename and Register

Read stages
</td>
<td width="313">WIDTH</td>
</tr>
<tr>
<td width="127">DI</td>
<td width="198">pipeline register between the Register Read and

Dispatch stages
</td>
<td width="313">WIDTH</td>
</tr>
<tr>
<td width="127">IQ</td>
<td width="198">Queue between the Dispatch and Issue stages</td>
<td width="313">IQ_SIZE</td>
</tr>
<tr>
<td width="127">execute_list</td>
<td width="198">execute_list represents the pipeline register between the Issue and Execute stages, as well as all subpipeline stages within each function unit.</td>
<td width="313">WIDTH*5

&nbsp;

There are WIDTH universal function units each with a maximum latency of 5 cycles. Hence, there can be as many as WIDTH*5 instructions in-flight within the Execute stage.
</td>
</tr>
<tr>
<td width="127">WB</td>
<td width="198">pipeline register between the Execute and Writeback stages

&nbsp;

<em>To maintain a non-blocking Execute stage, there is no constraint on the number of instructions &nbsp;&nbsp;&nbsp; that &nbsp;&nbsp;&nbsp;&nbsp; may complete in a cycle. </em>
</td>
<td width="313">WIDTH*5

&nbsp;

This is a conservative upper bound. If each function unit‚Äôs 5-stage pipeline is full with a 1-cycle (youngest), 2-cycle, 3-cycle, 4-cycle, and 5-cycle (oldest) operation, then all 5 instructions will complete in the same cycle. Multiply that by the number of such function units (WIDTH).
</td>
</tr>
<tr>
<td width="127">ROB</td>
<td width="198">Queue &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; between &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the

Writeback and Retire stages
</td>
<td width="313">ROB_SIZE</td>
</tr>
</tbody>
</table>
&nbsp;

<strong>About register values: </strong>

For the purpose of determining the number of cycles it takes for the microarchitecture to run a program, the simulator does not need to use and produce actual register values. This is why the initial Architectural Register File (ARF) values are not provided and the instruction opcodes are omitted from the trace. All that the simulator needs, to determine the number of cycles, is the microarchitecture configuration, execution latencies of instructions (operation type), and register specifiers of instructions (true, anti-, and output dependencies).

&nbsp;

<h2>5.2.&nbsp; Guide to Implementing your Simulator</h2>
This section provides a guide to implementing your simulator.

Call each pipeline stage in reverse order in your main simulator loop, as follows. The comments indicate tasks to be performed.

&nbsp;

<table width="624">
<tbody>
<tr>
<td width="192">do {

Retire();

Writeback();

Execute();

Issue();
</td>
<td width="432">// Retire up to WIDTH consecutive

// ‚Äúready‚Äù instructions from the head of

// the ROB.

&nbsp;

// Process the writeback bundle in WB:

// For each instruction in WB, mark the

// instruction as ‚Äúready‚Äù in its entry in

// the ROB.

&nbsp;

// From the execute_list, check for

// instructions that are finishing // execution <em>this</em> cycle, and:

// 1) Remove the instruction from //&nbsp;&nbsp;&nbsp; the execute_list. // 2) Add the instruction to WB.

// 3) Wakeup dependent instructions (set

//&nbsp;&nbsp;&nbsp; their source operand ready flags) in

//&nbsp;&nbsp;&nbsp; the IQ, DI (the dispatch bundle), and //&nbsp;&nbsp;&nbsp; RR (the register-read bundle).

&nbsp;

// Issue up to WIDTH oldest instructions

// from the IQ. (One approach to implement

// oldest-first issuing, is to make multiple

// passes through the IQ, each time finding

// the next oldest ready instruction and

// then issuing it. One way to annotate the

// age of an instruction is to assign an

// incrementing sequence number to each

// instruction as it is fetched from the // trace file.)
</td>
</tr>
</tbody>
</table>
// To issue an instruction: // 1) Remove the instruction from the IQ.

// 2) Add the instruction to the

//&nbsp;&nbsp;&nbsp; execute_list. Set a timer for the

//&nbsp;&nbsp;&nbsp; instruction in the execute_list that

//&nbsp;&nbsp;&nbsp; will allow you to model its execution

//&nbsp;&nbsp;&nbsp; latency.

&nbsp;

<table width="624">
<tbody>
<tr>
<td width="192">&nbsp;&nbsp;&nbsp;&nbsp; Dispatch();

RegRead();

Rename();
</td>
<td width="432">// If DI contains a dispatch bundle:

// If the number of free IQ entries is less

// than the size of the dispatch bundle in

// DI, then do nothing. If the number of

// free IQ entries is greater than or equal

// to the size of the dispatch bundle in DI,

// then dispatch all instructions from DI to

// the IQ.

&nbsp;

// If RR contains a register-read bundle:

// If DI is not empty (cannot accept a // new dispatch bundle), then do nothing.

// If DI is empty (can accept a new dispatch

// bundle), then process (see below) the

// register-read bundle and advance it from

// RR to DI.

//

// Since values are not explicitly modeled,

// the sole purpose of the Register Read

// stage is to ascertain the readiness of

// the renamed source operands. Apply your

// learning from the class lectures/notes on

// this topic.

//

// Also take care that producers in their

// last cycle of execution wakeup dependent

// operands not just in the IQ, but also in

// two other stages including RegRead()

// (this is required to avoid deadlock). See // Execute() description above.

&nbsp;

// If RN contains a rename bundle:

// If either RR is not empty (cannot accept

// a new register-read bundle) or the ROB

// does not have enough free entries to

// accept the entire rename bundle, then do

// nothing.

// If RR is empty (can accept a new

// register-read bundle) and the ROB has
</td>
</tr>
</tbody>
</table>
// enough free entries to accept the entire

// rename bundle, then process (see below)

// the rename bundle and advance it from

// RN to RR.

//

// Apply your learning from the class // lectures/notes on the steps for renaming:

// (1) allocate an entry in the ROB for the

// instruction, (2) rename its source

// registers, and (3) rename its destination

// register (if it has one). Note that the

// rename bundle must be renamed in program

// order (fortunately the instructions in // the rename bundle are in program order).

<table width="624">
<tbody>
<tr>
<td width="192">&nbsp;&nbsp;&nbsp;&nbsp; Decode();

Fetch();
</td>
<td width="432">// If DE contains a decode bundle:

// If RN is not empty (cannot accept a new // rename bundle), then do nothing.

// If RN is empty (can accept a new rename

// bundle), then advance the decode bundle

// from DE to RN.

&nbsp;

// Do nothing if either (1) there are no

// more instructions in the trace file or

// (2) DE is not empty (cannot accept a new

// decode bundle).

//

// If there are more instructions in the

// trace file and if DE is empty (can accept

// a new decode bundle), then fetch up to

// WIDTH instructions from the trace file

// into DE. Fewer than WIDTH instructions

// will be fetched only if the trace file // has fewer than WIDTH instructions left.
</td>
</tr>
</tbody>
</table>
&nbsp;

&nbsp;

&nbsp;

} while (Advance_Cycle()); // Advance_Cycle performs several functions.&nbsp; First, it advances the simulator cycle. Second, when it becomes known that the&nbsp; pipeline is empty AND the trace is depleted, the function returns ‚Äúfalse‚Äù to terminate the loop.

<h1>6.&nbsp; Submit, Validate, and Self-Grade with Gradescope</h1>
Sample simulation outputs are provided on the Moodle site. These are called ‚Äúvalidation runs‚Äù. <strong>Refer to the validation runs to see how to format the outputs of your simulator.</strong>

&nbsp;

<strong>You must submit, validate, and self-grade<a href="#_ftn2" name="_ftnref2"><sup>[2]</sup></a> your project using Gradescope.</strong> Here is how Gradescope (1) receives your project (zip file), (2) compiles your simulator (Makefile), and (3) runs and checks your simulator (arguments, print-to-console requirement, and ‚Äúdiff -iw‚Äù):

&nbsp;

<ol>
<li><strong>How Gradescope receives your project: zip file.</strong> While you are developing your simulator, you may continuously submit new zip files to Gradescope containing the latest version of your project. The latest submission is the one that is considered for your grade. Gradescope will accept a zip file consisting of three things: your source code, a Makefile to compile your source code, and your project report. In the early stages of your project, before creating the report, your zip file will have only source code and a Makefile. Once the report is completed, your zip file will contain everything.</li>
<li><u>Report (included in the zip file once available):</u> The report must be a PDF file named ‚Äúreport.pdf‚Äù located at the top level of the zip file, because that is what Gradescope looks for when checking completeness of the submission. <em>See Section 7 and the <u>required report template</u> in Moodle for the required contents of the report.</em>
<ul>
<li><u>Makefile:</u> The Makefile must be at the top level of the zip file, because Gradescope runs ‚Äúmake‚Äù with the expectation that the Makefile is at the top level.</li>
<li><u>Source code:</u> Whether your source code is at the top level of the zip file or in directories below the top level, your Makefile must be designed to compile your source code, accordingly.</li>
</ul>
</li>
</ol>
&nbsp;

<ol start="2">
<li><strong>How Gradescope compiles your simulator: Makefile.</strong> Along with your source code, you must provide a Makefile that automatically compiles the simulator. This Makefile must create a simulator named ‚Äúsim‚Äù. An example Makefile is posted on the Moodle site, which you can copy and modify for your needs.</li>
</ol>
&nbsp;

<ol start="3">
<li><strong>How Gradescope runs and checks your simulator: arguments, print-to-console requirement, ‚Äúdiff -iw‚Äù, and timeout.</strong>
<ul>
<li>Your simulator executable (created by your Makefile) must be named ‚Äúsim‚Äù and take command-line arguments in the manner specified in Section 3.2, because Gradescope assumes these things.</li>
<li>Your simulator must print outputs to the console (<em>e.</em>, to the screen), because Gradescope assumes this.</li>
<li>Your output must match the validation runs both <u>numerically</u> and in terms of <u>formatting</u>, because Gradescope runs ‚Äúdiff -iw‚Äù to compare your output with the correct output. The iw flags tell ‚Äúdiff‚Äù to treat upper-case and lower-case as equivalent and to ignore the amount of whitespace between words. Therefore, you do not need to worry about the exact number of spaces or tabs as long as there is some whitespace where the validation</li>
</ul>
</li>
</ol>
&nbsp;

runs have whitespace. Note, however, that extra or missing blank lines are NOT ok: ‚Äúdiff -iw‚Äù does not ignore extra or missing blank lines.

<ul>
<li>Gradescope‚Äôs autograder has a timeout for compiling the simulator and running all tests. The default timeout is 10 minutes. This is usually ample time for this course. If the autograder times out for your project (very inefficient simulator or a bug that causes deadlock), you will see a grade of zero for that submission. Please see Section 9.2 regarding optimizing run time. Also seek advice from the instructor and TAs, as needed.</li>
</ul>
&nbsp;

&nbsp;

&nbsp;

<h1>7.&nbsp; Grading Breakdown, Experiments, and Report</h1>
See the <u>required report template</u> in Moodle for the grading breakdown, experiments, and report contents.&nbsp; Use the report template as the basis for the report that you submit (insert graphs, fill in answers to questions, <em>etc</em>.).

<h1>8.&nbsp; Penalties</h1>
&nbsp;

Various deductions (out of 100 points):

&nbsp;

<strong>-1 point</strong> for each day (24-hour period) late, according to the Gradescope timestamp. The late penalty is pro-rated on an hourly basis: -1/24 point for each hour late. We will use the ‚Äúceiling‚Äù function of the lateness time to get to the next higher hour, <em>e.g.</em>, ceiling(10 min. late) = 1 hour late, ceiling(1 hr, 10 min. late) = 2 hours late, and so forth. <strong>For this third and final project, Gradescope will accept late submissions no more than one week after the deadline. The goal of this policy is to allow adequate time for the TAs to grade reports and assess partial credit for simulator development effort (for simulators that don‚Äôt match any validation runs), before final grades are due for the semester.</strong>

&nbsp;

<strong>See Section 1.1 for penalties and sanctions for academic integrity violations. </strong>

&nbsp;

<h1>9.&nbsp; Advice on backups and run time</h1>
<h2>9.1.&nbsp; Keeping backups</h2>
It is good practice to frequently make backups of all your project files, including source code, your report, <em>etc</em>.&nbsp; You can backup files to another hard drive (your NFS B: drive in your NCSU account, home PC, laptop ‚Ä¶ keep consistent copies in multiple places) or removable media

(flash drive, <em>etc</em>.).

<h2>9.2.&nbsp; Run time of simulator</h2>
<em>Correctness</em> of your simulator is of paramount importance. That said, making your simulator <em>efficient</em> is also important because you will be running many experiments: many superscalar processor configurations and multiple traces. Therefore, you will benefit from implementing a simulator that is reasonably fast.

&nbsp;

One simple thing you can do to make your simulator run faster is to compile it with a high optimization level. The example Makefile posted on the Moodle site includes the ‚ÄìO3 optimization flag.

&nbsp;

Note that, when you are debugging your simulator in a debugger (such as gdb), it is recommended that you compile without ‚ÄìO3 and with ‚Äìg. Optimization includes register allocation. Often, register-allocated variables are not displayed properly in debuggers, which is why you want to disable optimization when using a debugger. The ‚Äìg flag tells the compiler to include symbols (variable names, <em>etc</em>.) in the compiled binary. The debugger needs this information to recognize variable names, function names, line numbers in the source code, <em>etc</em>. When you are done debugging, recompile with ‚ÄìO3 and without ‚Äìg, to get the most efficient simulator again.

&nbsp;

As mentioned in Section 6, another reason for being wary of excessive run times is Gradescope‚Äôs autograder timeout.

&nbsp;

<h1>10.&nbsp; Scope Tool: An Optional Visualization Aid</h1>
I have written a tool that allows you to display instruction schedules identical to the ones drawn in class. You may use this tool as an <u>optional</u> visualization aid. o Download the scope tool from the Moodle website. o Run your simulator and redirect its output to some filename, &lt;scope-input-file&gt;.

<ul>
<li>Usage: scope &lt;scope-input-file&gt; &lt;scope-output-file&gt;</li>
<li>&lt;scope-output-file&gt;: This contains the instruction schedule. It is best displayed in a web browser because <em>some</em> web browsers provide horizontal scrollbars when lines are wider than your screen.</li>
</ul>
&nbsp;

Go to the Moodle website to view an example.

&nbsp;

&nbsp;

<a href="#_ftnref1" name="_ftn1">[1]</a> The ISA is MIPS-like: 32 integer registers, 32 floating-point registers, the HI and LO registers (for results of integer multiplication/divide), and the FCC register (floating-point condition code register).

<a href="#_ftnref2" name="_ftn2">[2]</a> The mystery runs component of your grade will not be published until we release it.&nbsp; The report will be manually graded by the TAs.
